# ============================================================================
# Tesslate Studio - Complete Configuration
# ============================================================================
# This file contains all configuration for Tesslate Studio.
# It is used by both Docker Compose and native development.
# For Kubernetes deployment, see k8s/.env.example
# ============================================================================

# Instructions:
# 1. Copy this file: cp .env.example .env
# 2. Update SECRET_KEY and LITELLM_MASTER_KEY below
# 3. For Docker Compose: docker compose up -d
# 4. For native development: Export these variables or use a .env loader
# 5. Never commit the .env file to version control

# ----------------------------------------------------------------------------
# Required Configuration
# ----------------------------------------------------------------------------

# Backend Secret Key (IMPORTANT: Change in production!)
SECRET_KEY=your-secret-key-here-change-this-in-production

# ----------------------------------------------------------------------------
# Database Configuration (PostgreSQL)
# ----------------------------------------------------------------------------

# PostgreSQL Database (used by both orchestrator and LiteLLM)
POSTGRES_DB=tesslate_dev
POSTGRES_USER=tesslate_user
POSTGRES_PASSWORD=dev_password_change_me
POSTGRES_PORT=5432

# ----------------------------------------------------------------------------
# LiteLLM Configuration (Required for AI features)
# ----------------------------------------------------------------------------
# External LiteLLM service configuration
# Point to your LiteLLM proxy server (shared between dev and production)

LITELLM_API_BASE=https://your-litellm-url.com/v1
LITELLM_MASTER_KEY=your-litellm-master-key-here

# LiteLLM User Configuration
# Models available to new users (comma-separated, no spaces)
# Example: gpt-4o-mini,gpt-3.5-turbo,claude-3-haiku,gemini-pro
# These should match model names configured in your LiteLLM proxy
LITELLM_DEFAULT_MODELS=gpt-4o-mini,gpt-3.5-turbo
# Team/access group for users in your LiteLLM setup
LITELLM_TEAM_ID=default
# Email domain for internal user emails
LITELLM_EMAIL_DOMAIN=localhost
# Initial budget per user in USD
LITELLM_INITIAL_BUDGET=10.0

# ----------------------------------------------------------------------------
# Agent Resource Limits (optional - has defaults)
# ----------------------------------------------------------------------------
# These limits prevent runaway costs and infinite loops in AI agents
# Limits are enforced globally across all agent executions

# Maximum total cost across all agent runs (USD)
# Default: 20.0
# AGENT_MAX_COST=20.0

# Maximum total iterations across all agent runs
# Default: 100
# AGENT_MAX_ITERATIONS=100

# Maximum cost per individual agent run (USD)
# Default: 5.0
# AGENT_MAX_COST_PER_RUN=5.0

# ----------------------------------------------------------------------------
# Container Cleanup Configuration (optional - has defaults)
# ----------------------------------------------------------------------------
# Two-tier cleanup system for idle development containers
# Helps manage resources and prevent runaway costs

# How often to run the cleanup check (minutes)
# CONTAINER_CLEANUP_INTERVAL_MINUTES=2

# Tier 1: Pause containers after being idle for X minutes
# CONTAINER_CLEANUP_TIER1_IDLE_MINUTES=15

# Tier 2: Remove containers after being paused for X hours
# CONTAINER_CLEANUP_TIER2_PAUSED_HOURS=24

# ----------------------------------------------------------------------------
# Optional Backend Configuration (has sensible defaults)
# ----------------------------------------------------------------------------

# Database URL (PostgreSQL - automatically configured for Docker Compose)
# Docker Compose: Uses postgres service (automatic)
# Production: Update with your PostgreSQL credentials
DATABASE_URL=postgresql+asyncpg://tesslate_user:dev_password_change_me@postgres:5432/tesslate_dev

# Logging Configuration (optional - has defaults)
# Log level for the backend application
# Options: DEBUG, INFO, WARNING, ERROR, CRITICAL
# Default: INFO
# LOG_LEVEL=INFO

# JWT Configuration (optional - has defaults)
# ALGORITHM=HS256
# ACCESS_TOKEN_EXPIRE_MINUTES=30
# REFRESH_TOKEN_EXPIRE_DAYS=14

# Deployment Mode (default: docker)
# Options: "docker" (local development) or "kubernetes" (production cluster)
DEPLOYMENT_MODE=docker

# File watching for dev containers (required for hot reload on Windows/Mac Docker)
# These settings enable file change detection in Docker volumes
CHOKIDAR_USEPOLLING=true
CHOKIDAR_INTERVAL=1000
WATCHPACK_POLLING=true

# ----------------------------------------------------------------------------
# Frontend Configuration
# ----------------------------------------------------------------------------

# Frontend API URL
# The backend API URL the frontend should connect to
#
# Docker Compose (Recommended):
#   VITE_API_URL=
#   (Empty uses Vite proxy which connects to orchestrator service in Docker)
#
# Native Development - Direct backend connection:
#   VITE_API_URL=http://localhost:8000
#
# Production - Different domain:
#   VITE_API_URL=https://api.yourdomain.com
#
VITE_API_URL=

# Frontend Allowed Hosts
# Comma-separated list of hostnames allowed to access the Vite dev server
# Used for Host header validation and security
# Leave commented for automatic configuration based on APP_DOMAIN
# VITE_ALLOWED_HOSTS=studio.tesslate.com,studio-test.tesslate.com,localhost

# ----------------------------------------------------------------------------
# Domain and Port Configuration
# ----------------------------------------------------------------------------

# Application Domain (no protocol, just domain)
# This is used for:
#   - Main app routing
#   - OAuth redirect URLs
#   - Subdomain-based project preview environments (project-slug.{APP_DOMAIN})
#   - CORS wildcard pattern matching (*.{APP_DOMAIN})
#
# Local development: localhost (recommended for OAuth compatibility)
# Production: studio.tesslate.com, yourdomain.com, etc.
APP_DOMAIN=localhost

# Traefik additional host rule (for accepting multiple domains)
# Development: Leave empty "" to only accept APP_DOMAIN (localhost)
# Production: Set to empty string "" to only accept APP_DOMAIN
# This adds extra hostnames to Traefik routing rules
TRAEFIK_ADDITIONAL_HOST_RULE=

# Application Protocol (http or https)
APP_PROTOCOL=http

# Application Ports
APP_PORT=80
APP_SECURE_PORT=443
TRAEFIK_DASHBOARD_PORT=8080
BACKEND_PORT=8000
FRONTEND_PORT=5173

# Base URL (complete URL with protocol and domain)
# This is automatically constructed from APP_PROTOCOL and APP_DOMAIN
# Or you can override it directly
APP_BASE_URL=${APP_PROTOCOL}://${APP_DOMAIN}

# Development Server Base URL (for preview containers)
# Docker mode: Leave empty (uses .localhost domains)
# Kubernetes mode: Set to your ingress domain
# DEV_SERVER_BASE_URL=https://studio-test.tesslate.com
DEV_SERVER_BASE_URL=

# ----------------------------------------------------------------------------
# CORS and Security Configuration
# ----------------------------------------------------------------------------

# CORS Allowed Origins (comma-separated list)
# Add all frontend URLs that should be allowed to access the API
# For local development with multiple domains, include both
# For production, include your production domain(s)
CORS_ORIGINS=${APP_BASE_URL},http://localhost

# Allowed Hosts (comma-separated list)
# List of hostnames allowed for Vite dev server and Content Security Policy
# IMPORTANT: Docker Compose doesn't expand ${APP_DOMAIN} in .env file values
# You must set this explicitly based on your APP_DOMAIN
# For local development (APP_DOMAIN=localhost): localhost
# For production (APP_DOMAIN=yourdomain.com): yourdomain.com
ALLOWED_HOSTS=${APP_DOMAIN}

# ----------------------------------------------------------------------------
# Traefik Configuration
# ----------------------------------------------------------------------------

# Traefik Basic Auth for Dashboard (optional)
# Generate with: htpasswd -nb admin your-password
# Default: admin:admin
TRAEFIK_BASIC_AUTH=admin:$$2y$$10$$EIHbchqg0sjZLr9iZINqA.6Za7wPjGAVdTER2ob5whDLtHkkZSGbC

# ----------------------------------------------------------------------------
# Authentication & OAuth Configuration
# ----------------------------------------------------------------------------

# Google OAuth (for login) - OPTIONAL
# See docs/GOOGLE_OAUTH_SETUP.md for detailed setup instructions
# Create OAuth credentials at: https://console.cloud.google.com/apis/credentials
# Authorized redirect URIs in Google Cloud Console:
#   - http://localhost/api/auth/google/callback (for local development)
#   - https://yourdomain.com/api/auth/google/callback (for production)
# If not configured, Google login will be disabled (graceful degradation)
# GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
# GOOGLE_CLIENT_SECRET=your-google-client-secret
# GOOGLE_OAUTH_REDIRECT_URI=http://localhost/api/auth/google/callback

# GitHub OAuth (for login) - OPTIONAL
# Create OAuth App at: https://github.com/settings/applications/new
# Authorization callback URL:
#   - http://localhost/api/auth/github/callback (for local development)
#   - https://yourdomain.com/api/auth/github/callback (for production)
# If not configured, GitHub login will be disabled (graceful degradation)
# GITHUB_CLIENT_ID=your_github_client_id
# GITHUB_CLIENT_SECRET=your_github_client_secret
# GITHUB_OAUTH_REDIRECT_URI=http://localhost/api/auth/github/callback

# Vercel OAuth (for deployments) - OPTIONAL
# Create Integration at: https://vercel.com/account/integrations
# Redirect URIs:
#   - http://localhost/api/deployment-oauth/vercel/callback (for local development)
#   - https://yourdomain.com/api/deployment-oauth/vercel/callback (for production)
# If not configured, Vercel deployments will require manual API tokens
# VERCEL_CLIENT_ID=your_vercel_client_id
# VERCEL_CLIENT_SECRET=your_vercel_client_secret
# VERCEL_OAUTH_REDIRECT_URI=http://localhost/api/deployment-oauth/vercel/callback

# Netlify OAuth (for deployments) - OPTIONAL
# Create OAuth App at: https://app.netlify.com/user/applications
# Redirect URIs:
#   - http://localhost/api/deployment-oauth/netlify/callback (for local development)
#   - https://yourdomain.com/api/deployment-oauth/netlify/callback (for production)
# If not configured, Netlify deployments will require manual API tokens
# NETLIFY_CLIENT_ID=your_netlify_client_id
# NETLIFY_CLIENT_SECRET=your_netlify_client_secret
# NETLIFY_OAUTH_REDIRECT_URI=http://localhost/api/deployment-oauth/netlify/callback

# CSRF Protection
# Separate secret key for CSRF tokens (optional - defaults to SECRET_KEY if not set)
# Generate a secure random string (32+ characters recommended)
# CSRF_SECRET_KEY=your-csrf-secret-key-here

# CSRF token maximum age in seconds
# Default: 86400 (24 hours)
# CSRF_TOKEN_MAX_AGE=86400

# Cookie Security Settings
# Set COOKIE_SECURE=true in production (requires HTTPS)
# Options: true, false
COOKIE_SECURE=false
# Cookie SameSite policy for CSRF protection
# Options: lax, strict, none
COOKIE_SAMESITE=lax
# Cookie domain for authentication cookies (IMPORTANT for subdomains)
# Local dev: Set to ".localhost" to work across localhost and project-slug.localhost
# Production: Set to your root domain (e.g., ".tesslate.com") to work across all subdomains
# Leave empty to restrict cookie to exact domain where it's set
COOKIE_DOMAIN=.localhost

# ----------------------------------------------------------------------------
# Deployment Configuration (Multi-Provider Deployments)
# ----------------------------------------------------------------------------

# Deployment Encryption Key (base64 encoded Fernet key)
# Used to securely encrypt deployment provider credentials (Cloudflare, Vercel, Netlify, etc.)
# If not set, will be derived from SECRET_KEY
# Generate a new key: python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
# DEPLOYMENT_ENCRYPTION_KEY=your_base64_fernet_key_here

# Deployment timeout in seconds (default: 600 = 10 minutes)
# Maximum time allowed for deployment operations
# DEPLOYMENT_TIMEOUT=600

# Default build output directory (default: dist)
# Can be overridden per framework (e.g., .next for Next.js, build for CRA)
# DEPLOYMENT_BUILD_DIR=dist

# Provider API Base URLs (optional - has defaults)
# Only override if you need to use different API endpoints
# CLOUDFLARE_API_BASE=https://api.cloudflare.com/client/v4
# VERCEL_API_BASE=https://api.vercel.com
# NETLIFY_API_BASE=https://api.netlify.com/api/v1

# ----------------------------------------------------------------------------
# PostHog Analytics (OPTIONAL)
# ----------------------------------------------------------------------------
VITE_PUBLIC_POSTHOG_KEY=your_posthog_key_here
VITE_PUBLIC_POSTHOG_HOST=https://us.i.posthog.com

# ----------------------------------------------------------------------------
# Stripe Configuration (for payments and subscriptions)
# ----------------------------------------------------------------------------

# Stripe API Keys
# Test mode keys: sk_test_*, pk_test_*
# Production mode keys: sk_live_*, pk_live_*
# Get from: https://dashboard.stripe.com/apikeys
STRIPE_SECRET_KEY=sk_test_your_stripe_secret_key_here
STRIPE_PUBLISHABLE_KEY=pk_test_your_stripe_publishable_key_here

# Stripe Webhook Secret
# Get from: https://dashboard.stripe.com/webhooks
# For local testing: Use Stripe CLI (stripe listen --forward-to localhost:8000/api/webhooks/stripe)
STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here

# Stripe Connect (for creator payouts)
# Get from: https://dashboard.stripe.com/settings/applications
STRIPE_CONNECT_CLIENT_ID=ca_your_connect_client_id_here

# ----------------------------------------------------------------------------
# Subscription Pricing Configuration
# ----------------------------------------------------------------------------

# Premium Subscription Price (in cents)
# Default: 500 = $5/month
PREMIUM_SUBSCRIPTION_PRICE=500

# Stripe Price ID for Premium Subscription
# Create in Stripe Dashboard: Products -> Create Product -> Recurring
# Must be a recurring price with monthly billing
STRIPE_PREMIUM_PRICE_ID=price_your_premium_subscription_price_id

# Credit Packages (in cents)
# Users can purchase credits to use for AI usage
CREDIT_PACKAGE_SMALL=500     # $5
CREDIT_PACKAGE_MEDIUM=1500   # $15
CREDIT_PACKAGE_LARGE=2500    # $25

# Deploy Pricing (in cents)
# Price per additional deploy slot beyond tier limits
ADDITIONAL_DEPLOY_PRICE=1000  # $10

# ----------------------------------------------------------------------------
# Subscription Tier Limits
# ----------------------------------------------------------------------------

# Free Tier Limits
FREE_MAX_PROJECTS=3  # Maximum active projects
FREE_MAX_DEPLOYS=1   # Maximum deployed projects
FREE_INITIAL_CREDITS=0  # Initial credits (in cents)

# Premium Tier Limits
PREMIUM_MAX_PROJECTS=20  # Maximum active projects
PREMIUM_MAX_DEPLOYS=5   # Maximum deployed projects
PREMIUM_INITIAL_CREDITS=0  # Initial credits (in cents)

# ----------------------------------------------------------------------------
# Revenue Sharing Configuration
# ----------------------------------------------------------------------------

# Creator revenue share (decimal, 0.90 = 90%)
CREATOR_REVENUE_SHARE=0.90

# Platform revenue share (decimal, 0.10 = 10%)
PLATFORM_REVENUE_SHARE=0.10

# ----------------------------------------------------------------------------
# Billing Settings
# ----------------------------------------------------------------------------

# Day of month to generate usage invoices (1-28)
# Monthly billing for API-based agent usage
USAGE_INVOICE_DAY=1

# ----------------------------------------------------------------------------
# Kubernetes Multi-Container Architecture (for DEPLOYMENT_MODE=kubernetes)
# ----------------------------------------------------------------------------

# Storage class for shared source code (must support ReadWriteMany for multi-container)
# Common options: nfs-client, efs-sc (AWS), azurefile (Azure), longhorn
# Optional - Default: nfs-client
# K8S_RWX_STORAGE_CLASS=nfs-client

# Ingress controller class name
# Common options: nginx, traefik, alb (AWS), gce (GCP)
# Optional - Default: nginx
# K8S_INGRESS_CLASS=nginx

# Enable namespace-per-project isolation (recommended for production)
# When true, each project gets its own namespace (proj-{uuid})
# When false, uses legacy shared namespace mode
# Optional - Default: true
# K8S_NAMESPACE_PER_PROJECT=true

# Enable NetworkPolicy creation for project isolation
# Requires CNI plugin with NetworkPolicy support (Calico, Cilium, Weave)
# Optional - Default: true
# K8S_ENABLE_NETWORK_POLICIES=true

# ----------------------------------------------------------------------------
# S3/Object Storage for Kubernetes Ephemeral Architecture (Hibernation)
# ----------------------------------------------------------------------------
# Enable S3-backed storage for Kubernetes mode (hibernation/hydration model)
# When true, project files are stored in S3 and loaded/saved on pod start/stop
# When false, uses persistent PVCs (default, recommended for multi-container)
# Optional - Default: false
# K8S_USE_S3_STORAGE=false

# S3-compatible storage settings (DigitalOcean Spaces, AWS S3, MinIO, etc.)
# Required if K8S_USE_S3_STORAGE=true
# S3_ACCESS_KEY_ID=your_s3_access_key_id
# S3_SECRET_ACCESS_KEY=your_s3_secret_access_key
# S3_ENDPOINT_URL=https://nyc3.digitaloceanspaces.com
# Optional - Default: tesslate-projects
# S3_BUCKET_NAME=tesslate-projects
# Optional - Default: us-east-1
# S3_REGION=us-east-1
# Optional - Default: projects
# S3_PROJECTS_PREFIX=projects

# Hibernation/Hydration settings (S3-backed storage mode)
# Optional - Default: 30
# K8S_HIBERNATION_IDLE_MINUTES=30
# Optional - Default: 300
# K8S_HYDRATION_TIMEOUT_SECONDS=300
# Optional - Default: 120
# K8S_DEHYDRATION_TIMEOUT_SECONDS=120

# Dynamic PVC settings (S3-backed storage mode)
# Optional - Default: do-block-storage
# K8S_PVC_STORAGE_CLASS=do-block-storage
# Optional - Default: 5Gi
# K8S_PVC_SIZE=5Gi
# Optional - Default: ReadWriteOnce
# K8S_PVC_ACCESS_MODE=ReadWriteOnce

